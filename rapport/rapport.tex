\documentclass[a4paper,11pt]{article}

\usepackage{lscape}
\usepackage{geometry}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{gantt}
\usepackage{tikz}
\usepackage{tikz-uml}
\usepackage{relsize}
\usepackage{color}
\usepackage[hidelinks]{hyperref}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\usepackage{listings}
\usepackage{float}
%\usepackage{kpfonts}

\usepackage{graphicx}
%\usepackage{rotating}

\lstset{
  language=C++,
  basicstyle=\footnotesize,
  backgroundcolor=\color{white},
  keywordstyle=\color{red},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  numberstyle=\color{red},
  morekeywords={string},
  frame=BL,
  aboveskip=1em,
  belowskip=2em,
}
\lstset{
  literate={ù}{{\`u}}1
  {é}{{\'e}}1
  {è}{{\'e}}1
  {à}{{\`a}}1
}


\lstdefinelanguage{tikzuml}{language=[LaTeX]TeX, classoffset=0, morekeywords={umlbasiccomponent, umlprovidedinterface, umlrequiredinterface, umldelegateconnector, umlassemblyconnector, umlVHVassemblyconnector, umlHVHassemblyconnector, umlnote, umlusecase, umlactor, umlinherit, umlassoc, umlVHextend, umlinclude, umlstateinitial, umlbasicstate, umltrans, umlstatefinal, umlVHtrans, umlHVtrans, umldatabase, umlmulti, umlobject, umlfpart, umlcreatecall, umlclass, umlvirt, umlunicompo, umlimport, umlaggreg}, classoffset=1, morekeywords={umlcomponent, umlsystem, umlstate, umlseqdiag, umlcall, umlcallself, umlfragment, umlpackage}, classoffset=0,  sensitive=true, morecomment=[l]{\%}}

\geometry{margin=2.5cm}
\geometry{headheight=15pt}

\usepackage{fancyhdr}
\usepackage{fancyvrb}
\usepackage{float}
\usepackage[footnote,smaller]{acronym}

\pagestyle{fancy}
\rhead{RE203 - Projet de Réseau}

% \acrodef{LABRI}{Laboratoire Bordelais de Recherche en Informatique}

\begin{document}

\begin{titlepage}
  \begin{center}

    \textsc{\LARGE RE203 - Projet de Réseau}\\[2cm]
    \textsc{\large Rapport Final}\\[3cm]
    Maxime \textsc{Bellier} \ \ \ Jean-Michaël \textsc{Celerier}\\
    Julien \textsc{Chaumont} \ \ \ Bazire \textsc{Houssin} \ \ \ Sylvain \textsc{Vaglica}\\[1cm]
    \textsc{Groupe 3}\\[1.5cm]
    \textsc{\large 23/05/2013 }\\[1.5cm] %TODO
    \includegraphics[width=8cm]{logo.png}

  \end{center}
  \vspace{3cm}

\end{titlepage}

\clearpage

\section*{Introduction}

Ce rapport final pour le projet de réseau RE203 fait suite au rapport intermédiaire délivré le 23 avril dernier. Il sera ici question de l'implémentation mise en \oe uvre par notre groupe, l'explication du sujet ayant été développée précédemment.

\section{Le bloc commun}

Étant donné que le développement des deux parties du projet (contrôleur et routeur) a été réalisé respectivement dans les langages C et C++, il a été décidé d'établir une sorte bibliothèque commune sur laquelle se baser. Cette partie comprend:
\begin{itemize}
 \item une invite de commande
 \item un système de gestion des fichiers de configuration
 \item des fonctions de traitement des messages reçus et à envoyer
 \item une API pour la gestion des sockets
 \item quelques fonctions utilitaires
\end{itemize}

Chacun de ces blocs est indépendant des autres, ce qui assure une intégration facilitée dans le contrôleur comme dans le routeur. Une telle organisation permet d'introduire un certain degré d'abstraction tout en limitant la redondance
de code entre les deux composantes du projet.

\subsection{Le prompt}

\underline{Fichiers :} \texttt{common/prompt.c}, \texttt{common/prompt.h}\\

L'invite de commande, ou \textit{prompt} en Anglais, permet la communication entre le contrôleur ou le routeur, et l'utilisateur. Il suffit pour cela de regarder constamment sur l'entrée standard et de traiter les commandes saisies par l'utilisateur. Afin de ne pas bloquer le programme sur l'écoute du fichier \texttt{stdin}, il faut pouvoir exécuter cette tâche en parallèle, d'où l'utilisation de la bibliothèque \texttt{pthread} ici.

Les fonctions définies dans les fichiers sus-mentionnés assurent la création de ce thread et l'écoute sur l'entrée standard. Le paramètre à fournir à la fonction d'initialisation est un pointeur de fonction. Lorsqu'une information arrive, elle est mise en mémoire et convertie en un \texttt{Message}\footnote{Se référer à la partie \ref{message}}, et c'est à la fonction dont le pointeur est passé en paramètre de gérer les actions à effectuer suite à la réception de ce message.

De cette manière, contrôleur et routeur ont seulement à gérer la fonction de traitement des messages utilisateur (chaque programme devant comprendre des commandes qui lui sont spécifiques), mais la tâche de récupération des instructions de l'utilisateur est quant à elle unifiée.

\subsection{Traitement des fichiers de configuration}

\underline{Fichiers :} \texttt{common/config.c}, \texttt{common/config.h}\\

Le sujet demandait à ce que routeur comme contrôleur puissent être paramétrés depuis un fichier de configuration. Ce module permet la lecture de ces fichiers. La bibliothèque C \texttt{T-Rex}\footnote{Publiée sous licence libre \textit{zlib} par Alberto Demichelis, consultable à l'adresse \url{http://sourceforge.net/projects/tiny-rex/}}, qui permet la manipulation d'expressions régulières, a été utilisée dans ce cadre afin de faciliter la reconnaissance des différentes lignes possibles dans les fichiers de configuration.

Dans le code du routeur (respectivement du contrôleur), il suffit d'appeler la fonction \texttt{config\_\_readRouter} (respectivement \texttt{config\_\_readController}). En interne, ces fonctions ouvrent le fichier de configuration indiqué, le lisent ligne par ligne, identifient les mots-clés à l'aide des expressions régulières, et remplissent une variable de type \texttt{Configuration} avec les informations contenues dans le fichier. Cette structure de données est déclarée de la manière suivante:

\begin{lstlisting}
enum SoftwareType { ROUTER, CONTROLLER };

typedef struct Configuration
{
	enum SoftwareType type;
	char controllerAddress[20];
	int  routerPort;
	int  controllerPort;
	int  pollTimeoutValue;
	int  controllerUpdateInterval;
	int  routerUpdateInterval;
	int  defaultTTLValue;
	int  defaultPingPacketCount;
	int  defaultPacketTimeoutValue;
	int  defaultDVTimeoutValue;
} Configuration;
\end{lstlisting}

A la fin de la lecture, il ne reste plus qu'à retourner au programme appelant un pointeur vers la structure remplie, qui n'aura alors qu'à consulter la valeur de ses différents attributs.

Notez que la structure \texttt{Configuration} contient des attributs concernant aussi bien le contrôleur que le routeur. C'est au programme de veiller à n'utiliser que les attributs le concernant, les autres attributs n'ayant aucune garantie d'avoir été initialisés à une valeur cohérente (précisons cependant qu'il n'y a aucune raison pour que le contrôleur ait besoin des informations propres aux routeurs, et inversement).

\subsection{Le système des \texttt{Messages}}
\label{message}

\underline{Fichiers :} \texttt{common/messages.c}, \texttt{common/messages.h}\\

Les \texttt{Messages} correspondent à une structure de données relative aux informations reçues et transmises par le contrôleur, le routeur ou l'utilisateur. Ce module permet notamment:
\begin{itemize}
 \item L'allocation et la libération dynamique d'un message
 \item L'échappement d'une chaîne de caractères (caractères "*" et "\textbackslash"), à utiliser lors de l'envoi d'un \texttt{Message}, et l'opération inverse pour la réception
 \item Le parsing, c'est-à-dire la reconnaissance de la commande contenue dans le \texttt{Message} (là aussi, la bibliothèque \texttt{T-Rex} est mise à contribution)
 \item La gestion du TTL
\end{itemize}
La structure \texttt{Message} contient toutes les informations nécessaires au traitement ultérieur.

\begin{lstlisting}
typedef struct Message
{
	enum MessageType type;  //Type du message (login, poll, ping, load, ...)
	char *s_parameter;      //Paramètre de la commande (identifiants, ...)
	int  n_parameter;       //Paramètre de la commande (numéro de port, ...)
	char *node1, *node2;    //Identifiants de l'émetteur et du récepteur
	int  seqnum;            //Numéro de séquence
	enum Acceptance accept; //Type de retour
} Message;
\end{lstlisting}

\subsection{La gestion des sockets}

\subsubsection{La structure \texttt{Client}}

\underline{Fichiers :} \texttt{common/client.c}, \texttt{common/client.h}\\

La structure \texttt{Client} sert de base à la gestion des communications par socket. Elle permet l'association d'un routeur par son identifiant à une socket (qui contient à la fois l'adresse IP et le port à utiliser pour établir une communication avec ce client). Les fonctions fournies avec ce module permettent la récupération du port, de l'adresse et de l'identifiant d'un client, la mise à jour de l'identifiant ou encore la comparaison de deux \texttt{Client}s.

La fonction \texttt{getsockname} de la bibliothèque \texttt{sys/socket.h}, en addition des fonctions \texttt{inet\_ntoa} et \texttt{ntohs}, permet de récupérer séparément, et sans difficulté majeure, l'adresse et le numéro de port depuis une socket.

\subsubsection{Les sockets}

\underline{Fichiers :} \texttt{common/net.c}, \texttt{common/net.h}, \texttt{common/sock.h}\\

Il s'agit certainement du pilier du projet, puisque c'est ce module qui assure la communication entre les routeurs et/ou le contrôleur en réseau. L'idée était en fait de réaliser une couche d'abstraction au-dessus de la bibliothèque \texttt{sys/socket.h}.

La structure de données utilisée ici se nomme \texttt{network}, et représente le réseau.
\begin{lstlisting}
struct network_s{
  short status; //Réseau ouvert ou fermé
  SOCKET server;//Socket du serveur
  int max;      //Nombre maximum de sockets à ouvrir
  Client *clients; //Clients connectés
  unsigned int nb_clients; //Taille du tableau précédent

  /* Fonctions d'événement */
  //Fonction à appeler lorsque l'entrée standard a été utilisée
  input_event_function input_event;
  //Fonction à appeler lors de la connexion d'un client
  connection_event_function connection_event;
  //Fonction à appeler lors de la déconnexion d'un client
  disconnection_event_function disconnection_event;
  //Fonction à appeler lors de la réception d'un message
  message_event_function message_event;
};
\end{lstlisting}

Une fois les fonctions d'initialisation appelées, la fonction \texttt{network\_\_update} permet l'écoute \textit{non bloquante} (à l'aide de la fonction de multiplexage de la librairie standard \texttt{select}) sur le port indiqué. A chaque événement (\textit{ie} connexion ou déconnexion d'un client, réception d'un message, \dots), la fonction continue le traitement en analysant le type de l'événement qui l'aura réveillé et en appelant les fonctions correspondantes dont les pointeurs sont indiqués dans la structure \texttt{network} utilisée. Ce sera le rôle de ces fonctions de gérer les actions à mettre en place, ce qui dépend évidemment de s'il s'agit du contrôleur ou d'un routeur, et doivent donc être implémentées et initialisées directement depuis le programme utilisant le module.

\section{Le contrôleur}

En se basant sur le code du bloc commun, il est plus facile d'écrire un code propre et bien organisé. Cette seconde partie détaille l'implémentation du contrôleur.

\subsection{Gestion des graphes}

\underline{Fichiers :} \texttt{controller/graphlib.c}, \texttt{controller/graphlib.h}\\

La première action à effectuer sur le contrôleur est le chargement de la topologie d'un réseau sous la forme d'un fichier au format \textit{dot}. A cet effet, il a fallu mettre en place un système de gestion de graphes facilitant les interactions entre le format \textit{dot} et la représentation en mémoire: la librairie de graphes de \textit{graphviz}\footnote{Publiée sous licence libre Eclipse, consultable à l'adresse \url{http://www.graphviz.org/}} était incontestablement la plus apte à répondre à ce problème. Dans un souci de propreté du code, une couche d'abstraction a été, ici aussi, mise en place au dessus de \textit{graphviz}.

Dans la pratique, le programme agit sur une variable globale de type \texttt{Agraph\_t}. Cette structure contient en fait l'arbre correspondant à la topologie du réseau chargé, où chaque n\oe ud est un routeur, et où chaque arête indique le voisinage de deux routeurs et est labellisée du poids du chemin représenté. \textit{graphviz} offre toutes les fonctions nécessaires au traitement d'une telle variable, de son initialisation à l'aide d'un fichier \textit{.dot} à sa sauvegarde, et évidemment l'ajout/suppression/modification de tout n\oe ud ou arête.

\subsection{Table des routeurs}

\underline{Fichiers :} \texttt{controller/info\_table.c}, \texttt{controller/info\_table.h}\\

Un structure de table de hachage est utilisée dans le code du contrôleur. Son rôle est de faire le lien entre l'identifiant d'un routeur (son nom) et la structure \texttt{Client} qui lui est associée et qui permet la communication. Pour cela, cette partie du code source se base sur la bibliothèque \textit{Hash-Table}\footnote{Publiée sous licence libre GNU/GPL par Ankur Shrivastava, consultable à l'adresse \url{https://github.com/ankurs/Hash-Table/}} en C, qui a le grand avantage d'être très simple d'utilisation, en plus d'avoir une documentation bien exhaustive. Après initialisation de la structure, celle-ci est mise à jour à chaque connexion et déconnexion d'un routeur sur le réseau. Dans le cas d'une connexion, rappelons que le bloc de gestion des sockets gère de lui-même l'allocation et l'initialisation d'une structure \texttt{Client}.

Travailler sur une telle structure de données permet d'optimiser la complexité temporelle de la recherche des informations de connexion d'un routeur donné.

\subsection{Traitement des commandes}

\section{Les routeurs}

De même que pour le contrôleur, une partie du code du routeur se base sur le code commun présenté précédemment.

Néanmoins, le défi repose dans le fait que le routeur est écrit en C++, et que bien qu'il y ait un fort lien de parenté
entre les deux langages, il est parfois nécessaire de connaître quelques astuces pour pouvoir interfacer les deux codes.

De plus, nous nous sommes efforcés d'adopter une architecture MVC (Modèle-Vue-Contrôleur) : nous avons entièrement séparé les classes qui servent
à l'entrée - sortie, des classes qui servent à la gestion du logiciel, et la majorité des appels passent par une classe contrôleur.

\subsection{Diagramme de classes}

\subsection{La classe Router}

\underline{Classe : \texttt{Router}}\\

Cette classe est la classe principale du programme. Elle est instanciée dans le main, et instancie par la suite toutes les autres
classes du logiciel; c'est le contrôleur (au sens MVC) du logiciel.

Elle contient notamment la table de routage, ainsi que la plupart des classes qui gèrent les messages, et gère les threads
qui servent à communiquer périodiquement avec le contrôleur et les autres routeurs (par le biais des commandes \texttt{poll} et \texttt{vector}).

\subsection{La table de routage : RouteTable}

\underline{Classes : \texttt{RouteTable}, \texttt{Entry}}\\

Nous avons utilisé pour la table de routage un simple tableau associatif (le \textbf{map} du C++).
Nous associons au nom du routeur voisin une structure, \texttt{Entry}, qui contient différentes informations nécessaires
à la communication avec ces clients.

\texttt{Entry} contient un pointeur vers un \texttt{Client}, présenté précédemment, la distance entre deux noeuds, ainsi que
le prochain saut à effectuer pour rejoindre un noeud.

\subsection{Gestion des messages}

\underline{Classes : \texttt{Event}, \texttt{Exec}}\\

Grâce à l'architecture choisie, la gestion de la communication est sensiblement semblable à celle utilisée dans le
routeur.

Le prompt (classe\texttt{Prompt}) ainsi que la pseudo-classe \texttt{net} de la partie commune communiquent avec la classe \texttt{Exec},
 qui est chargée de la compréhension et de l'application des actions requises lors de la réception d'un message.

Nous avons utilisé de plus le même système d'évènements qu'en C, ce qui a posé des problèmes d'incompatibilité de prototypes : en effet,
nous avons créé la classe Event qui contient les évènements à exécuter en cas d'opération sur le réseau. Mais le prototype attendu par la fonction C
est incompatible avec une méthode d'instance, qui contient un paramètre caché \textbf{this}.

Il a donc été nécessaire d'avoir une variable globale vers la classe \texttt{Router} pour accéder à toutes les informations nécessaires (table de routage...) dans la classe \texttt{Event}.
Ce n'est certes pas une bonne pratique de programmation, mais cela permet de n'avoir qu'un seul code pour le routeur et le contrôleur.

\texttt{Exec} contient la logique des opérations à réaliser (ex. : si le message est de type neighborhood, et que son niveau d'acceptation est OK, alors ne rien faire, sinon faire le traitement nécessaire sur le message).

Mais la plupart du traitement se déroule dans des classes séparées : \texttt{PromptActions} et \texttt{SockActions}.

\texttt{PromptActions} contient les actions à réaliser pour un message rentré à la main, et \texttt{SockActions} en fait de
même pour un message reçu par le réseau.

A la différence de \texttt{Exec}, ces deux classes manipulent directement les fonctions contenues dans \texttt{net.c}.
Ce sont elles qui forment les messages à envoyer par le réseau, notamment, en remplissant les membres de la structure Message.

\subsection{Classes annexes}

\underline{Classes : \texttt{Display}, \texttt{exceptions diverses et variées}}\\

Display sert à l'affichage des données du programme, des réponses aux messages, des messages d'erreurs, tel que spécifié dans le sujet.
Exceptions est une liste de dérivés de \texttt{std::exception}, instanciés, de manière à pouvoir s'en servir très simplement.

Elle est entièrement contenue dans un fichier header.

Par exemple, voici l'utilisation de l'exception pour l'absence d'un routeur dans la table de routage : Unknown destination.
La casse est impoortante.

\begin{lstlisting}
throw unknownDest; // envoi
\end{lstlisting}

\begin{lstlisting}
catch(UnknownDest&) // récupération
\end{lstlisting}

Cela permet un code clair.
\end{document}
